// Copyright Â© 2024 Stephan Kunz

//! Implementation of an [`Agent`]'s communicator
//!

// region:		--- modules
#[cfg(feature = "unstable")]
use dimas_com::traits::LivelinessSubscriber;
use dimas_com::traits::{
	MultiSessionCommunicator, Observer, Publisher, Querier, Responder,
	SingleSessionCommunicatorMethods,
};
use dimas_com::{enums::CommunicatorImplementation, traits::MultiSessionCommunicatorMethods};
use dimas_config::Config;
use dimas_core::message_types::{Message, QueryableMsg};
use dimas_core::{enums::OperationState, traits::Capability, Result};
use std::{
	collections::HashMap,
	sync::{Arc, RwLock},
};
use tracing::error;
use zenoh::config::ZenohId;

use crate::error::Error;
// endregion:   --- modules

// region:		--- types
// the initial size of the HashMaps
const INITIAL_SIZE: usize = 9;
// endregion:	--- types

// region:      --- Communicator
#[derive(Debug)]
pub struct Communicator {
	/// a uuid generated by default zenoh session
	uuid: ZenohId,
	/// the mode of default zenoh session
	mode: String,
	/// The [`Communicator`]s current operational state.
	state: OperationState,
	/// Registered Communicators
	communicators: Arc<RwLock<HashMap<String, Arc<CommunicatorImplementation>>>>,
	/// Registered [`LivelinessSubscriber`]
	#[cfg(feature = "unstable")]
	liveliness_subscribers: Arc<RwLock<HashMap<String, Box<dyn LivelinessSubscriber>>>>,
	/// Registered [`Observer`]
	observers: Arc<RwLock<HashMap<String, Box<dyn Observer>>>>,
	/// Registered [`Publisher`]
	publishers: Arc<RwLock<HashMap<String, Box<dyn Publisher>>>>,
	/// Registered [`Query`]s
	queriers: Arc<RwLock<HashMap<String, Box<dyn Querier>>>>,
	/// Registered [`Observable`]s, [`Queryable`]s and [`Subscriber`]s
	responders: Arc<RwLock<HashMap<String, Box<dyn Responder>>>>,
}

impl Capability for Communicator {
	fn manage_operation_state(&self, new_state: &OperationState) -> Result<()> {
		if new_state >= &self.state {
			self.upgrade_registered_tasks(new_state)?;
		} else if new_state < &self.state {
			self.downgrade_registered_tasks(new_state)?;
		}
		Ok(())
	}
}

impl MultiSessionCommunicatorMethods for Communicator {
	fn put_from(&self, session_id: &str, selector: &str, message: Message) -> Result<()> {
		let publishers = self
			.publishers
			.read()
			.map_err(|_| Error::ReadAccess)?;

		#[allow(clippy::single_match_else)]
		match publishers.get(selector) {
			Some(publisher) => publisher.put(message),
			None => {
				let comm = self
					.communicators
					.read()
					.map_err(|_| Error::ReadAccess)?
					.get(session_id)
					.ok_or_else(|| Error::NoCommunicator(session_id.into())).cloned()?;

				#[allow(clippy::match_wildcard_for_single_variants)]
				match comm.as_ref() {
					CommunicatorImplementation::Zenoh(zenoh) => {
						zenoh.put(selector, message)
					}
					_ => Err(Error::NotImplemented.into()),
				}
			}
		}
	}

	fn delete_from(&self, session_id: &str, selector: &str) -> Result<()> {
		let publishers = self
			.publishers
			.read()
			.map_err(|_| Error::ReadAccess)?;

		#[allow(clippy::single_match_else)]
		match publishers.get(selector) {
			Some(publisher) => publisher.delete(),
			None => {
				let comm = self
					.communicators
					.read()
					.map_err(|_| Error::ReadAccess)?
					.get(session_id)
					.ok_or_else(|| Error::NoCommunicator(session_id.into())).cloned()?;

				#[allow(clippy::match_wildcard_for_single_variants)]
				match comm.as_ref() {
					CommunicatorImplementation::Zenoh(zenoh) => {
						zenoh.delete(selector)
					}
					_ => Err(Error::NotImplemented.into()),
				}
			}
		}
	}

	fn get_from(
		&self,
		session_id: &str,
		selector: &str,
		message: Option<Message>,
		callback: Option<&mut dyn FnMut(QueryableMsg) -> Result<()>>,
	) -> Result<()> {
		let queriers = self
			.queriers
			.read()
			.map_err(|_| Error::ReadAccess)?;

		#[allow(clippy::single_match_else)]
		match queriers.get(selector) {
			Some(querier) => querier.get(message, callback),
			None => {
				let comm = self
					.communicators
					.read()
					.map_err(|_| Error::ReadAccess)?
					.get(session_id)
					.ok_or_else(|| Error::NoCommunicator(session_id.into())).cloned()?;

					#[allow(clippy::match_wildcard_for_single_variants)]
					match comm.as_ref() {
					CommunicatorImplementation::Zenoh(zenoh) => {
						callback.map_or_else(|| Err(Error::NotImplemented.into()), |callback| zenoh.get(selector, message, callback))
					}
					_ => Err(Error::NotImplemented.into()),
				}
			}
		}
	}

	fn observe_from(&self, session_id: &str, selector: &str, message: Option<Message>) -> Result<()> {
		let observers = self
			.observers
			.read()
			.map_err(|_| Error::ReadAccess)?;

		#[allow(clippy::single_match_else)]
		match observers.get(selector) {
			Some(observer) => observer.request(message),
			None => {
				let comm = self
					.communicators
					.read()
					.map_err(|_| Error::ReadAccess)?
					.get(session_id)
					.ok_or_else(|| Error::NoCommunicator(session_id.into())).cloned()?;

				#[allow(clippy::match_wildcard_for_single_variants)]
				match comm.as_ref() {
					CommunicatorImplementation::Zenoh(_zenoh) => {
						Err(Error::NotImplemented.into())
					}
					_ => Err(Error::NotImplemented.into()),
				}
			}
		}
	}

	fn watch_from(&self, _session: &str, _selector: &str, _message: Message) -> Result<()> {
		println!("Communicator watch");
		Err(Error::ManageState.into())
	}
}

impl MultiSessionCommunicator for Communicator {
	#[allow(clippy::match_wildcard_for_single_variants)]
	fn session(&self, session_id: &str) -> Option<Arc<zenoh::Session>> {
		let com = self
			.communicators
			.read()
			.expect("snh")
			.get(session_id)
			.cloned()
			.expect("snh");
		match com.as_ref() {
			CommunicatorImplementation::Zenoh(communicator) => {
				let com = communicator.session();
				Some(com)
			}
			_ => None,
		}
	}
}

impl Communicator {
	pub(crate) fn new(config: &Config) -> Result<Self> {
		let zenoh = dimas_com::zenoh::Communicator::new(config)?;
		let uuid = zenoh.session().zid();
		let mode = zenoh.mode().to_string();
		let com = Self {
			uuid,
			mode,
			state: OperationState::Created,
			communicators: Arc::new(RwLock::new(HashMap::with_capacity(INITIAL_SIZE))),
			#[cfg(feature = "unstable")]
			liveliness_subscribers: Arc::new(RwLock::new(HashMap::with_capacity(INITIAL_SIZE))),
			observers: Arc::new(RwLock::new(HashMap::with_capacity(INITIAL_SIZE))),
			publishers: Arc::new(RwLock::new(HashMap::with_capacity(INITIAL_SIZE))),
			queriers: Arc::new(RwLock::new(HashMap::with_capacity(INITIAL_SIZE))),
			responders: Arc::new(RwLock::new(HashMap::with_capacity(INITIAL_SIZE))),
		};
		// add the default communicator
		com.communicators
			.write()
			.map_err(|_| Error::ModifyStruct("commmunicators".into()))?
			.insert(
				"default".to_string(),
				Arc::new(CommunicatorImplementation::Zenoh(zenoh)),
			);
		Ok(com)
	}

	/// Get the liveliness subscribers
	#[cfg(feature = "unstable")]
	#[must_use]
	pub(crate) fn liveliness_subscribers(
		&self,
	) -> &Arc<RwLock<HashMap<String, Box<dyn LivelinessSubscriber>>>> {
		&self.liveliness_subscribers
	}

	/// Get the observers
	#[must_use]
	pub(crate) const fn observers(&self) -> &Arc<RwLock<HashMap<String, Box<dyn Observer>>>> {
		&self.observers
	}

	/// Get the publishers
	#[must_use]
	pub(crate) fn publishers(&self) -> Arc<RwLock<HashMap<String, Box<dyn Publisher>>>> {
		self.publishers.clone()
	}

	/// Get the queries
	#[must_use]
	pub(crate) const fn queriers(&self) -> &Arc<RwLock<HashMap<String, Box<dyn Querier>>>> {
		&self.queriers
	}

	/// Get the responders
	#[must_use]
	pub(crate) const fn responders(&self) -> &Arc<RwLock<HashMap<String, Box<dyn Responder>>>> {
		&self.responders
	}

	/// Internal function for starting all registered tasks.<br>
	/// The tasks are started in the order
	/// - [`LivelinessSubscriber`]s
	/// - [`Responders`]s
	/// - [`Publisher`]s the
	/// - [`Observer`]s and the
	/// - [`Query`]s
	///
	/// # Errors
	/// Currently none
	fn upgrade_registered_tasks(&self, new_state: &OperationState) -> Result<()> {
		// start liveliness subscriber
		#[cfg(feature = "unstable")]
		self.liveliness_subscribers
			.write()
			.map_err(|_| Error::ModifyStruct("liveliness subscribers".into()))?
			.iter_mut()
			.for_each(|subscriber| {
				let _ = subscriber.1.manage_operation_state(new_state);
			});

		// start all registered responders
		self.responders
			.write()
			.map_err(|_| Error::ModifyStruct("subscribers".into()))?
			.iter_mut()
			.for_each(|subscriber| {
				let _ = subscriber.1.manage_operation_state(new_state);
			});

		// init all registered publishers
		self.publishers
			.write()
			.map_err(|_| Error::ModifyStruct("publishers".into()))?
			.iter_mut()
			.for_each(|publisher| {
				if let Err(reason) = publisher.1.manage_operation_state(new_state) {
					error!(
						"could not initialize publisher for {}, reason: {}",
						publisher.1.selector(),
						reason
					);
				};
			});

		// init all registered observers
		self.observers
			.write()
			.map_err(|_| Error::ModifyStruct("observers".into()))?
			.iter_mut()
			.for_each(|observer| {
				if let Err(reason) = observer.1.manage_operation_state(new_state) {
					error!(
						"could not initialize observer for {}, reason: {}",
						observer.1.selector(),
						reason
					);
				};
			});

		// init all registered queries
		self.queriers
			.write()
			.map_err(|_| Error::ModifyStruct("queries".into()))?
			.iter_mut()
			.for_each(|query| {
				if let Err(reason) = query.1.manage_operation_state(new_state) {
					error!(
						"could not initialize query for {}, reason: {}",
						query.1.selector(),
						reason
					);
				};
			});

		Ok(())
	}

	/// Internal function for stopping all registered tasks.<br>
	/// The tasks are stopped in reverse order of their start in [`start_registered_tasks()`]
	///
	/// # Errors
	/// Currently none
	fn downgrade_registered_tasks(&self, new_state: &OperationState) -> Result<()> {
		// reverse order of start!
		// de-init all registered queries
		self.queriers
			.write()
			.map_err(|_| Error::ModifyStruct("queries".into()))?
			.iter_mut()
			.for_each(|query| {
				if let Err(reason) = query.1.manage_operation_state(new_state) {
					error!(
						"could not de-initialize query for {}, reason: {}",
						query.1.selector(),
						reason
					);
				};
			});

		// de-init all registered observers
		self.observers
			.write()
			.map_err(|_| Error::ModifyStruct("observers".into()))?
			.iter_mut()
			.for_each(|observer| {
				if let Err(reason) = observer.1.manage_operation_state(new_state) {
					error!(
						"could not de-initialize observer for {}, reason: {}",
						observer.1.selector(),
						reason
					);
				};
			});

		// de-init all registered publishers
		self.publishers
			.write()
			.map_err(|_| Error::ModifyStruct("publishers".into()))?
			.iter_mut()
			.for_each(|publisher| {
				let _ = publisher.1.manage_operation_state(new_state);
			});

		// stop all registered responders
		self.responders
			.write()
			.map_err(|_| Error::ModifyStruct("subscribers".into()))?
			.iter_mut()
			.for_each(|subscriber| {
				let _ = subscriber.1.manage_operation_state(new_state);
			});

		// stop all registered liveliness subscribers
		#[cfg(feature = "unstable")]
		self.liveliness_subscribers
			.write()
			.map_err(|_| Error::ModifyStruct("liveliness subscribers".into()))?
			.iter_mut()
			.for_each(|subscriber| {
				let _ = subscriber.1.manage_operation_state(new_state);
			});

		Ok(())
	}

	pub(crate) fn uuid(&self) -> String {
		self.uuid.to_string()
	}

	pub(crate) const fn mode(&self) -> &String {
		&self.mode
	}
}
// endregion:   --- Communicator

#[cfg(test)]
mod tests {
	use super::*;

	// check, that the auto traits are available
	const fn is_normal<T: Sized + Send + Sync>() {}

	#[test]
	const fn normal_types() {
		is_normal::<Communicator>();
	}
}
